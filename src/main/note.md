算法的时间复杂度和空间复杂度
==
---
* 时间复杂度：用于评估执行程序所消耗的时间，可以估算程序对存储器的使用程度。
* 空间复杂度：用于评估执行程序所占用的内存空间，可以估算出程序对计算机内存的使用程序。

---
一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况。最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差。

通常，时间复杂度要比空间复杂度更容易出问题，更多研究的是时间复杂度，面试中如果没有特殊说明，讲的也是时间复杂度。

---
> 时间频度：我们把一个算法中的语句执行次数称为时间频度，记作T(n)。

> 在时间频度T(n)中，n代表着问题的规模，当n不断变化时，T(n)也会不断地随之变化。那么，如果我们想知道T(n)随着n变化时会呈现出什么样的规律，那么就需要引入时间复杂度的概念。

> 如果存在某个函数f(n)，使得当n趋于无穷大时，T(n)/f(n)的极限值是不为零的常数，那么f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称为时间复杂度。
>> 算法的时间复杂度函数为：T(n)=O(f(n))；
`T(n)=O(f(n))表示存在一个常数C，使得在当n趋于正无穷时总有 T(n) ≤ C * f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T(n)的上界是C * f(n)。其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。`
---
### 常见的时间复杂度有：
* O(1)常数型；
* O(log n)对数型，
* O(n)线性型，
* O(nlog n)线性对数型，
* O(n2)平方型，
* O(n3)立方型，
* O(nk)k次方型，
* O(2n)指数型。
![comparing Big O Function](/Users/chenjiena/IdeaProjects/LeetCode/src/resources/comparingBigOFunction.jpg)

---
> 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)。

### 时间复杂度实例：

>常数阶O(1):<br>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：
```text
int i = 1;
int j = 2;
int k = 1 + 2;
```

>对数阶O(log n):<br> 语句①的频度为1，可以忽略不计。语句②我们可以看到它是以2的倍数来逼近n，每次都乘以2。如果用公式表示就是122*2…*2 <=n，也就是说2的x次方小于等于n时会执行循环体，记作2^x <= n，于是得出x<=logn。也就是说上述循环在执行logn次之后，便结束了，因此上述代码的时间复杂度为O(log n)。
其实上面代码的时间复杂度公式如果精确的来讲应该是：T(n) = 1 + O(log n)，但我们上面已经讲到对应的原则，“只保留时间函数中的最高阶项”，因此记作O(log n)。
```text
int i = 1; // ①
while (i <= n) {
   i = i * 2; // ②
}
```

>线性阶O(n):<br>语句①的频度为1，②的频度为n，③的频度为n-1，④的频度为n-1，因此整个算法可以用公式T(n)=1+n+(n-1)+(n-1)来表示。进而可以推到T(n)=1+n+(n-1)+(n-1)=3n-1，即O(n)=3n-1，去掉低次幂和系数即O(n)=n，因此T(n)=O(n)。
在上述代码中for循环中的代码会执行n遍，因此它消耗的时间是随着n的变化而成线性变化的，因此这类算法都可以用O(n)来表示时间复杂度。
```text
int j = 0; // ①
for (int i = 0; i < n; i++) { // ②
   j = i; // ③
   j++; // ④
}
```

>线性对数阶O(nlogN):<br>线性对数阶要对照对数阶 O(log n)来进行理解。上述代码中for循环内部的代码便是上面讲到对数阶，只不过在对数阶的外面套了一个n次的循环，当然，它的时间复杂度就是n*O(log n)了，于是记作O(nlog n)。
```text
for (int m = 1; m < n; m++) {
   int i = 1; // ①
   while (i <= n) {
      i = i * 2; // ②
   }
}
```

>平方阶O(n²):<br>平方阶可对照线性阶来进行理解，我们知道线性阶是一层for循环，记作O(n)，此时等于又嵌套了一层for循环，那么便是n * O(n)，也就是O(n * n)，即O(n^2)。
```text
int k = 0;
for (int i = 0; i < n; i++) {
   for (int j = 0; j < n; j++) {
      k++;
   }
}
```
```text
int k = 0;
for (int i = 0; i < m; i++) {
   for (int j = 0; j < n; j++) {
      k++;
   }
}

对应的时间复杂度便为：O(m * n)。
```
>同理，立方阶O(n³)、K次方阶O(n^k)，只不过是嵌套了3层循环、k层循环而已。

### 排序算法对比
![function_table](/Users/chenjiena/IdeaProjects/LeetCode/src/resources/functionTable.jpg)

### 空间复杂度
>程序执行除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间。
存储空间通常包括：指令空间（即代码空间）、数据空间（常量、简单变量）等所占的固定部分和动态分配、递归栈所需的可变空间。
其中可变空间与算法有关。 一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))其中n为问题的规模，S(n)表示空间复杂度。
>> 下面看两个常见的空间复杂度示例：空间复杂度O(1)和O(n)。

#### 空间复杂度O(1)
```text
int i = 1;
int j = 2;
int k = 1 + 2;
```
>上述代码中临时空间并不会随着n的变化而变化，因此空间复杂度为O(1)。总结一下就是：如果算法执行所需要的临时空间不随着某个变量n的大小而变化，此算法空间复杂度为一个常量，可表示为 O(1)，即 S(n) = O(1)。

#### 空间复杂度O(n)
```text
int j = 0;
int[] m = new int[n];
for (int i = 1; i <= n; ++i) {
   j = i;
   j++;
}
```
>只有创建int数组分配空间时与n的大小有关，而for循环内没有再分配新的空间，因此，对应的空间复杂度为S(n) = O(n)。

 